# Doczilla Test Project

Это тествовый проект на Java с тремя заданиями (Task 1–3), реализующими разные сервисы и алгоритмы. Проект построен с использованием Gradle и использует сторонние библиотеки там, где это необходимо.

---

## Структура проекта

doczilla-test/

    ├─ build.gradle # корневой Gradle-файл

    ├─ settings.gradle # подключение подпроектов

    ├─ task1-liquid-sort/ # Задание 1: сортировка жидкостей

    ├─ task2-file-service/ # Задание 2: сервис работы с файлами

    └─ task3-weather-service/ # Задание 3: сервис прогноза погоды

Каждое задание имеет свой подпроект с отдельным `build.gradle` и исходным кодом в `src/main/java`.

## Зависимости

Проект использует следующие технологии и библиотеки:

- **Java 19 или 21**
- **Gradle 8.x**
- **Redis** (для Task 3, localhost:6379)
- **org.json:json:20230227** – работа с JSON (Task 3)
- **redis.clients:jedis:5.4.0** – клиент Redis (Task 3)
- **org.knowm.xchart:xchart:3.9.2** – графики (Task 3)

Все зависимости подтягиваются автоматически через Gradle при сборке проекта.

## Общая установка

1. **Склонировать проект и перейти в директорию:**

`
git clone <репозиторий> `


`cd doczilla-test `

2. **Склонировать проект и перейти в директорию:**

`
./gradlew build
`
3. **Запуск конкретного задания описан ниже в соответствующем разделе:**

Последующие команды должны реалиховываться из папки doczilla-test

Task 1 : ` ./gradlew :task1-liquid-sort:run `

Task 2: `./gradlew :task2-file-service:run`

Task 3: `./gradlew :task3-weather-service:run --args="Moscow" `


## Task 1 — Liquid Sort

**Папка:** `task1-liquid-sort/`

**Описание:**  
Task 1 реализует задачу сортировки жидкостей в трубках. Цель — упорядочить капли одного цвета в отдельные трубки. Для этого используется алгоритм поиска решения с возвратом (DFS) и итеративный поиск с отслеживанием состояния.

---

### Основные компоненты

- **Tube.java** — класс, представляющий одну трубку с каплями. Поддерживает:
    - проверку на пустоту и заполненность (`isEmpty()`, `isFull()`)
    - получение верхнего цвета и количества верхних капель одного цвета (`topColor()`, `countTopColor()`)
    - переливание в другую трубку (`pourInto(Tube other)`)
    - проверку, однородна ли трубка или пуста (`isUniformOrEmpty()`)
    - клонирование состояния трубки (`cloneTube()`)

- **GameState.java** — состояние игры (все трубки), включает:
    - проверку, решена ли задача (`isSolved()`)
    - проверку возможности переливания между трубками (`canPour(int from, int to)`)
    - выполнение переливания (`pour(int from, int to)`)
    - кодирование состояния для отслеживания посещённых вариантов (`encodeState()`)

- **Solver.java** — решатель задачи:
    - `solve()` — рекурсивный DFS с ограничением глубины
    - `solveIterative()` — итеративный поиск с использованием стека
    - оптимизация: сначала рассматриваются пустые трубки, переливание только возможное по правилам

- **GameStateWithMoves.java** — вспомогательный класс для хранения состояния игры и сделанных ходов.

- **App.java** — точка входа программы:
    - инициализация трубок с начальной расстановкой капель
    - запуск решателя (`Solver.solveIterative`)
    - вывод найденной последовательности ходов и времени выполнения

---

### Пример запуска

В корне проекта:

` ./gradlew :task1-liquid-sort:run `


# Task 2 — File Service

**Папка:** `task2-file-service/`

**Описание:**  
Task 2 реализует сервис обмена файлами на Java без фреймворков. Пользователи могут загружать файлы через веб-форму и получать уникальную ссылку для скачивания. Файлы автоматически удаляются, если их не скачивали в течение заданного срока (по умолчанию 30 дней).

Frontend реализован на **Vanilla JS, HTML и CSS** с индикатором загрузки и ссылкой на скачивание.

---

## Основные компоненты

- **Main.java** — точка входа:
    - Настройка и запуск `HttpServer` на порту 8080
    - Создание контекстов:
        - `/` — отдаёт `index.html` (frontend)
        - `/upload` — обработка загрузки файлов (`UploadHandler`)
        - `/download` — скачивание файлов по UUID (`DownloadHandler`)
    - Запуск фонового `FileCleaner` для удаления старых файлов

- **UploadHandler.java** — обработка POST-запросов для загрузки файлов:
    - Генерация уникального идентификатора файла (UUID)
    - Сохранение файла в папку `storage/`
    - Возврат JSON с идентификатором файла

- **DownloadHandler.java** — обработка GET-запросов для скачивания файлов:
    - Проверка существования файла
    - Обновление времени последнего скачивания (`lastModified`) для работы cleaner
    - Отправка файла клиенту с заголовком `Content-Disposition` для корректного скачивания

- **FileCleaner.java** — фоновая задача для удаления файлов:
    - Периодический запуск (каждые 24 часа)
    - Проверка возраста файлов по времени последнего скачивания
    - Удаление файлов, которые не скачивали дольше `maxAgeDays` (30 дней)

- **index.html** — frontend:
    - Форма для выбора и загрузки файла
    - Прогресс-бар отображает статус загрузки
    - После успешной загрузки отображается уникальная ссылка для скачивания файла

---

## Пример запуска

`./gradlew :task2-file-service:run
`

Откройте браузер:
http://localhost:8080


## Task 3 — Weather Service

**Папка:** `task3-weather-service/`

**Описание:**  
Task 3 реализует сервис прогноза погоды для выбранного города с визуализацией температуры за 24 часа. Сервис использует Open-Meteo API для получения координат города и прогноза погоды, кэширует данные в Redis с TTL 15 минут и строит графики через XChart.

---

### Основные компоненты

- **Client.java** — класс для работы с внешними сервисами и кэшем:
    - Получение координат города через Open-Meteo Geocoding API
    - Получение прогноза на 24 часа через Open-Meteo Forecast API
    - Кэширование данных в Redis с TTL 15 минут
    - Инкапсуляция всей логики взаимодействия с API и Redis

- **WeatherChart.java** — построение графиков температуры:
    - `plot(JSONObject weather)` — визуализирует температуру по часам
    - Используется библиотека XChart

- **Main.java** — точка входа:
    - Чтение аргумента с названием города (по умолчанию Berlin)
    - Получение информации о городе и прогнозе погоды через `Client`
    - Вызов построения графика через `WeatherChart`
    - Вывод информации и графика пользователю

---

### Пример запуска

Убедитесь, что локальный сервер Redis запущен:

`redis-server `

Запуск сервиса с указанием города, например Moscow:

`./gradlew :task3-weather-service:run --args="Moscow"  `




